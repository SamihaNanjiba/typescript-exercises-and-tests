// Write a function that takes a callback function and a delay in milliseconds. The function should invoke the callback after the specified delay.
// export const delayedCallback = () => {}

// Write a function that makes a GET request to a specified URL and returns a Promise that resolves with the response data.
// export const fetchData = () => {}

// Write a function that takes an array of asynchronous functions (callbacks or Promises) and executes them sequentially, waiting for each one to finish before starting the next one.
// export const sequentialExecution = () => {}

// Write a function that takes an array of asynchronous functions (callbacks or Promises) and executes them in parallel, returning a Promise that resolves with an array of their results.
// export const parallelExecution = () => {}

// Write a function that takes an array of Promises and returns a Promise that resolves with an array of objects representing the outcome of each Promise, whether it was fulfilled or rejected.
// export const promiseAllSettled = () => {}

// Write a function that takes an array and an asynchronous mapping function, and returns a Promise that resolves with an array of mapped values.
// export const asyncMap = () => {}

// Write a function that takes a callback function and a time interval. The function should ensure that the callback is not called more than once during the specified interval.
// export const throttle = () => {}

// Write a function that takes a callback function and a delay. The function should ensure that the callback is only called after a certain amount of time has passed without being called again.
// export const debounce = () => {}

// Write a function that takes an asynchronous function and returns a cached version of it. The cached version should memoize the results of the original function to avoid redundant computations.
// export const cachedFetchData = () => {}

// Write a function that takes an asynchronous function and a lock object. The function should ensure that only one call to the asynchronous function can be made at a time, even if it is called concurrently.
// export const asyncFunc = () => {}